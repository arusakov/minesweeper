{"version":3,"sources":["controls.module.sass","utils.ts","Tile.tsx","GameArea.tsx","Controls.tsx","App.tsx","reportWebVitals.ts","index.tsx","Tile.module.sass","GameArea.module.sass"],"names":["module","exports","TILE_SIZE","TILE_WIDTH","CELL_WIDTH","encodePosition","top","left","decodePosition","pos","createMatrix","rows","columns","matrix","Array","i","createTile","tile","Uint8Array","updateTile","newTiles","oldTiles","ti","tj","item","oldTile","slice","CELL_OPENED","initCells","realTop","realLeft","gameStatic","gameData","Math","max","min","floor","iInTile","j","jInTile","cell","probability","opened","mines","inited","isMine","Boolean","random","ii","tii","iiInTile","jj","tjj","jjInTile","tileIfMine","cellValue","Tile","memo","tileTop","tileLeft","onClick","onContextMenu","cells","className","css","mine","content","flag","getCellData","push","undefined","e","preventDefault","style","GameArea","props","areaRef","createRef","rowTiles","columnTiles","failedTileColumn","failedTileRow","queue","Denque","set","Set","tilesSet","intervalId","flags","updateTilesSides","current","sides","el","scrollTop","scrollLeft","clientWidth","clientHeight","right","bottom","calSides","setState","tileBottom","tileRight","onCellClick","finished","unshift","openEmptyCells","clearInterval","window","setInterval","openMinesCells","onFinish","tiles","step","tilePostion","shift","delete","r","c","CELL_MINE","distance","abs","has","add","initCellsForMines","state","length","counter","position","onCellFlag","ceil","addEventListener","this","removeEventListener","currentTiles","area","ref","onScroll","container","width","height","renderTiles","React","Component","getResultText","result","Controls","game","onChange","useState","setRows","setColumns","setMines","controls","onSubmit","name","Number","currentTarget","value","type","App","setGame","gameCounter","setGameCounter","setResult","g","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fbfb8b81.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"controls\":\"controls_controls__3zSnP\"};","import Denque from \"denque\"\n\nexport const MAX_CELLS = 10000\n\nexport const CELL_WIDTH = 18\n\nexport const TILE_SIZE = 16\n\nexport const TILE_WIDTH = CELL_WIDTH * TILE_SIZE\n\nexport type GameStatic = {\n  rows: number\n  columns: number\n  mines: number\n}\n\nexport type GameData = {\n  inited: number\n  mines: number\n  opened: number\n  rowTiles: number\n  queue: Denque<number>\n  set: Set<number>\n  columnTiles: number\n  failedTileRow: number\n  failedTileColumn: number\n}\n\nexport type TileObj = Array<Uint8Array>\nexport type Tiles = Array<Array<TileObj | undefined>>\n\nexport const encodePosition = (top: number, left: number) =>\n  (top << 16) | left\n\nexport const decodePosition = (pos: number) => ({\n  top: pos >> 16,\n  left: 0xFFFF & pos,\n})\n\n\nexport type Sides = {\n  top: number\n  left: number\n  right: number\n  bottom: number\n}\n\n\nexport const calSides = (el: HTMLDivElement): Sides => {\n  const { scrollTop, scrollLeft, clientWidth, clientHeight } = el\n\n  return {\n    top: Math.floor(scrollTop / TILE_WIDTH),\n    left: Math.floor(scrollLeft / TILE_WIDTH),\n    right: Math.floor((scrollLeft + clientWidth) / TILE_WIDTH),\n    bottom: Math.floor((scrollTop + clientHeight) / TILE_WIDTH),\n  }\n}\n\nexport const createMatrix = <T>(rows: number, columns: number) => {\n  const matrix = new Array<Array<T | undefined>>(rows)\n  for (let i = 0; i < rows; ++i) {\n    matrix[i] = new Array<T | undefined>(columns)\n  }\n  return matrix\n}\n\nexport const createTile = (rows: number, columns: number) => {\n  const tile = new Array<Uint8Array>(rows)\n  for (let i = 0; i < rows; ++i) {\n    tile[i] = new Uint8Array(columns)\n  }\n  return tile\n}\n\nexport const updateTile = (newTiles: Tiles, oldTiles: Tiles, ti: number, tj: number, item: number, top: number, left: number) => {\n  const oldTile = oldTiles[ti][tj]\n  let tile = newTiles[ti][tj]\n  if (!tile || tile === oldTile) {\n    if (tile) {\n      tile = tile.slice()\n      tile[top] = tile[top].slice()\n    } else {\n      tile = createTile(TILE_SIZE, TILE_SIZE)\n    }\n    newTiles[ti] = newTiles[ti].slice()\n    newTiles[ti][tj] = tile\n  }\n  tile[top][left] = item\n  return tile\n}\n\nexport const CELL_OPENED = 0b10000000\nexport const CELL_INIT = 0b01000000\nexport const CELL_MINE = 0b00100000\nexport const CELL_FLAG = 0b00010000\n\nexport const initCells = (newTiles: Tiles, oldTiles: Tiles, realTop: number, realLeft: number, gameStatic: GameStatic, gameData: GameData) => {\n\n  for (let i = Math.max(0, realTop - 1); i <= Math.min(gameStatic.rows - 1, realTop + 1); ++i) {\n    const ti = Math.floor(i / TILE_SIZE)\n    const iInTile = i % TILE_SIZE\n\n    for (let j = Math.max(0, realLeft - 1); j <= Math.min(gameStatic.columns - 1, realLeft + 1); ++j) {\n      const tj = Math.floor(j / TILE_SIZE)\n      const jInTile = j % TILE_SIZE\n\n      const tile = newTiles[ti][tj]\n\n      const cell = tile ? tile[iInTile][jInTile] : 0\n\n      if (!(cell & CELL_INIT)) {\n        const probability = (realTop === i && realLeft === j ? gameData.opened : true) && (\n          (gameStatic.mines - gameData.mines) / (gameStatic.columns * gameStatic.rows - gameData.inited)\n        )\n\n        const isMine = Boolean(probability) && Math.random() < probability\n        updateTile(newTiles, oldTiles, ti, tj, cell | CELL_INIT | (isMine ? CELL_MINE : 0), iInTile, jInTile)\n\n        if (isMine) {\n          gameData.mines += 1\n\n          for (let ii = Math.max(0, i - 1); ii <= Math.min(gameStatic.rows - 1, i + 1); ++ii) {\n            const tii = Math.floor(ii / TILE_SIZE)\n            const iiInTile = ii % TILE_SIZE\n            for (let jj = Math.max(0, j - 1); jj <= Math.min(gameStatic.columns - 1, j + 1); ++jj) {\n              const tjj = Math.floor(jj / TILE_SIZE)\n              const jjInTile = jj % TILE_SIZE\n              const tileIfMine = newTiles[tii][tjj]\n\n              const cellValue = tileIfMine? tileIfMine[iiInTile][jjInTile] : 0\n              updateTile(newTiles, oldTiles, tii, tjj, cellValue + 1, iiInTile, jjInTile)\n            }\n          }\n        }\n\n        gameData.inited += 1\n      }\n    }\n  }\n}\n\nexport const initCellsForMines = (tiles: Array<Array<TileObj | undefined>>, gameStatic: GameStatic, gameData: GameData) => {\n  const newTiles = tiles.slice()\n\n  const { queue, set } = gameData\n\n  for (let step = 0; step < 32; ++step) {\n    const tilePostion = queue.shift()\n    if (tilePostion == null) {\n      break\n    }\n\n    set.delete(tilePostion)\n\n    const { top, left } = decodePosition(tilePostion)\n\n    const tile = newTiles[top][left] || createTile(TILE_SIZE, TILE_SIZE)\n\n    for (let i = 0; i < TILE_SIZE * TILE_SIZE; ++i) {\n      const r = Math.floor(i / TILE_SIZE)\n      const c = i % TILE_SIZE\n\n      if (top * TILE_SIZE + r >= gameStatic.rows || left * TILE_SIZE + c >= gameStatic.columns) {\n        continue\n      }\n\n      const cell = tile[r][c]\n\n      if (!(cell & CELL_INIT)) {\n        const probability = (gameStatic.mines - gameData.mines) / (gameStatic.columns * gameStatic.rows - gameData.inited)\n        gameData.inited += 1\n\n        const isMine = Math.random() < probability\n        gameData.mines += isMine ? 1 : 0\n\n        updateTile(newTiles, newTiles, top, left, cell | CELL_INIT | (isMine ? CELL_MINE | CELL_OPENED : 0), r, c)\n      } else if (cell & CELL_MINE) {\n        updateTile(newTiles, newTiles, top, left, cell | CELL_OPENED, r, c)\n      }\n    }\n\n\n    const distance = Math.abs(top - gameData.failedTileRow) + Math.abs(left - gameData.failedTileColumn)\n\n\n    for (let i = Math.max(0, top - 1); i <= Math.min(gameData.rowTiles - 1, top + 1); ++i) {\n      for (let j = Math.max(0, left - 1); j <= Math.min(gameData.columnTiles - 1, left + 1); ++j) {\n        if (Math.abs(i - gameData.failedTileRow) + Math.abs(j - gameData.failedTileColumn) <= distance) {\n          continue\n        }\n\n        const pos = encodePosition(i, j)\n        if (set.has(pos)) {\n          continue\n        }\n        queue.push(pos)\n        set.add(pos)\n      }\n    }\n\n  }\n  return newTiles\n}\n\n\nexport const openEmptyCells = (tiles: Tiles, gameStatic: GameStatic, gameData: GameData) => {\n  const { queue, set } = gameData\n\n  let newTiles = tiles.slice()\n\n  for (let counter = 0; counter < 512; ++counter) {\n    const position = queue.shift()\n    if (position == null) {\n      break\n    }\n    set.delete(position)\n\n    const { top, left } = decodePosition(position)\n\n    initCells(newTiles, tiles, top, left, gameStatic, gameData)\n\n    const ti = Math.floor(top / TILE_SIZE)\n    const tj = Math.floor(left / TILE_SIZE)\n    const tii = top % TILE_SIZE\n    const tjj = left % TILE_SIZE\n\n    const tile = newTiles[ti][tj] as Uint8Array[]\n    const cell = tile[tii][tjj]\n\n\n    updateTile(newTiles, tiles, ti, tj, cell | CELL_OPENED, tii, tjj)\n    gameData.opened += 1\n\n    if (cell & 0b00001111) {\n      continue\n    }\n\n    for (let i = Math.max(0, top - 1); i <= Math.min(gameStatic.rows - 1, top + 1); ++i) {\n      for (let j = Math.max(0, left - 1); j <= Math.min(gameStatic.columns - 1, left + 1); ++j) {\n        if (i === top && j === left) {\n          continue\n        }\n        if (newTiles[Math.floor(i / TILE_SIZE)][Math.floor(j / TILE_SIZE)]![i % TILE_SIZE][j % TILE_SIZE] & CELL_OPENED) {\n          continue\n        }\n        const pos = encodePosition(i, j)\n        if (set.has(pos)) {\n          continue\n        }\n        queue.push(pos)\n        set.add(pos)\n      }\n    }\n  }\n\n  return newTiles\n}\n","import React, { memo } from 'react'\n\nimport { CELL_FLAG, CELL_MINE, CELL_OPENED, CELL_WIDTH, TileObj, TILE_SIZE, TILE_WIDTH } from './utils'\n\nimport css from './Tile.module.sass'\n\ntype Props = {\n  tileTop: number\n  tileLeft: number\n  tile?: TileObj\n  onClick: (tileTop: number, tileLeft: number, top: number, left: number) => void\n  onContextMenu: (tileTop: number, tileLeft: number, top: number, left: number) => void\n}\n\nconst getCellData = (cell: number) => {\n  if (cell & CELL_OPENED) {\n    if (cell & CELL_MINE) {\n      return {\n        className: css.mine,\n        content: null,\n      }\n    }\n    return {\n      content: cell & 0b00001111 || null,\n      className: css.opened,\n    }\n  }\n  return {\n    content: null,\n    className: cell & CELL_FLAG ? css.flag : '',\n  }\n}\n\nexport const Tile: React.FC<Props> = memo(({ tileTop, tileLeft, onClick, onContextMenu, tile }) => {\n\n  const cells = []\n  for (let i = 0; i < TILE_SIZE; ++i) {\n    for (let j = 0; j < TILE_SIZE; ++j) {\n      const cell = (tile && tile[i][j]) || 0\n      const opened = Boolean(cell & CELL_OPENED)\n      const { className, content } = getCellData(cell)\n      cells.push(\n        <div\n          key={i * TILE_SIZE + j}\n          onClick={opened || (cell & CELL_FLAG) ? undefined : (() => onClick(tileTop, tileLeft, i, j))}\n          onContextMenu={opened ? undefined : ((e) => { e.preventDefault(); onContextMenu(tileTop, tileLeft, i, j) })}\n          className={className}\n          style={{\n            top: i * CELL_WIDTH,\n            left: j * CELL_WIDTH\n          }}>\n          {content}\n        </div>\n      )\n    }\n  }\n\n  return (\n    <div className={css.tile} style={{ top: tileTop * TILE_WIDTH, left: tileLeft * TILE_WIDTH }}>\n      {cells}\n    </div>\n  )\n})","import React, { createRef } from 'react'\nimport {\n  calSides, CELL_FLAG, CELL_MINE, CELL_WIDTH,\n  createMatrix,\n  createTile,\n  encodePosition, GameData, GameStatic,\n  initCellsForMines,\n  openEmptyCells, Tiles, TILE_SIZE, updateTile\n} from './utils'\nimport { Tile } from './Tile'\n\nimport css from './GameArea.module.sass'\nimport Denque from 'denque'\n\ntype Props = {\n  gameStatic: GameStatic\n  finished: boolean\n  onFinish: (result: boolean) => void\n}\n\ntype State = {\n  tiles: Tiles\n  tileTop: number\n  tileLeft: number\n  tileRight: number\n  tileBottom: number\n}\n\nexport class GameArea extends React.Component<Props, State> implements GameData {\n\n  areaRef = createRef<HTMLDivElement>()\n\n  rowTiles: number\n  columnTiles: number\n\n  failedTileColumn = 0\n  failedTileRow = 0\n  queue = new Denque<number>()\n  set = new Set<number>()\n  tilesSet = new Set<number>()\n  intervalId = 0\n  \n\n  mines = 0\n  inited = 0\n  opened = 0\n  flags = 0\n\n  constructor(props: Props) {\n    super(props)\n\n    const { gameStatic } = props\n\n    this.rowTiles = Math.ceil(gameStatic.rows / TILE_SIZE)\n    this.columnTiles = Math.ceil(gameStatic.columns / TILE_SIZE)\n\n    this.state = {\n      tiles: createMatrix(this.rowTiles, this.columnTiles),\n      tileTop: 0,\n      tileLeft: 0,\n      tileRight: -1,\n      tileBottom: -1,\n    }\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.updateTilesSides)\n    this.updateTilesSides()\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.updateTilesSides)\n    clearInterval(this.intervalId)\n  }\n\n  updateTilesSides = () => {\n    if (!this.areaRef.current) {\n      return\n    }\n    const sides = calSides(this.areaRef.current)\n    this.setState({\n      tileBottom: Math.min(sides.bottom, this.rowTiles - 1),\n      tileLeft: sides.left,\n      tileRight: Math.min(sides.right, this.columnTiles - 1),\n      tileTop: sides.top,\n    })\n  }\n\n  onCellClick = (tileTop: number, tileLeft: number, top: number, left: number) => {\n    if (this.props.finished) {\n      return\n    }\n    const realTop = tileTop * TILE_SIZE + top\n    const realLeft = tileLeft * TILE_SIZE + left\n\n    this.queue.unshift(encodePosition(realTop, realLeft))\n\n    const newTiles = this.openEmptyCells()\n\n    if (newTiles[tileTop][tileLeft]![top][left] & CELL_MINE) {\n      clearInterval(this.intervalId)\n      this.failedTileColumn = tileLeft\n      this.failedTileRow = tileTop\n      this.queue = new Denque([encodePosition(tileTop, tileLeft)])\n      this.intervalId = window.setInterval(this.openMinesCells, 200)\n\n      this.props.onFinish(false)\n    }\n  }\n\n  openMinesCells = () => {\n    const { tiles } = this.state\n    const { gameStatic } = this.props\n\n    const newTiles = initCellsForMines(tiles, gameStatic, this)\n    this.setState({ tiles: newTiles })\n\n    if (this.queue.length) {\n      if (!this.intervalId) {\n        this.intervalId = window.setInterval(this.openMinesCells, 200)\n      }\n    } else {\n      clearInterval(this.intervalId)\n    }\n  }\n\n  openEmptyCells = () => {\n    const { tiles } = this.state\n    const { gameStatic } = this.props\n\n    const newTiles = openEmptyCells(tiles, gameStatic, this)\n\n    if (this.queue.length) {\n      if (!this.intervalId) {\n        this.intervalId = window.setInterval(this.openEmptyCells, 200)\n      }\n    } else {\n      clearInterval(this.intervalId)\n    }\n\n    if (this.opened + gameStatic.mines === gameStatic.columns * gameStatic.rows) {\n      this.props.onFinish(true)\n    }\n\n    this.setState({ tiles: newTiles })\n    return newTiles\n  }\n\n  onCellFlag = (tileTop: number, tileLeft: number, top: number, left: number) => {\n    if (this.props.finished) {\n      return\n    }\n    const newTiles = this.state.tiles.slice()\n    const tile = newTiles[tileTop][tileLeft]\n    const cell =  tile ? tile[top][left] : 0\n\n    if (!(cell & CELL_FLAG) && this.flags >= this.props.gameStatic.mines) {\n      return\n    }\n\n    this.flags += cell & CELL_FLAG ? -1 : 1\n    updateTile(newTiles, this.state.tiles, tileTop, tileLeft, cell ^ CELL_FLAG, top, left)\n\n    this.setState({ tiles: newTiles })  \n  }\n\n  renderTiles() {\n    const { tileBottom, tileLeft, tileRight, tileTop, tiles } = this.state\n\n    const currentTiles = []\n    for (let i = tileTop; i <= tileBottom; ++i) {\n      for (let j = tileLeft; j <= tileRight; ++j) {\n        currentTiles.push(<Tile\n          tile={tiles[i][j]}\n          key={encodePosition(i, j)}\n          tileLeft={j}\n          tileTop={i}\n          onClick={this.onCellClick}\n          onContextMenu={this.onCellFlag}\n        />)\n      }\n    }\n    return currentTiles\n  }\n\n  render() {\n    const { gameStatic } = this.props\n    return (\n      <div className={css.area} ref={this.areaRef} onScroll={this.updateTilesSides}>\n        <div\n          className={css.container}\n          style={{\n            width: gameStatic.columns * CELL_WIDTH + 1,\n            height: gameStatic.rows * CELL_WIDTH + 1,\n          }}>\n          {this.renderTiles()}\n        </div>\n      </div>\n    )\n  }\n}","import React, { useState } from 'react'\nimport { GameStatic, MAX_CELLS } from './utils'\n\nimport css from  './controls.module.sass'\n\ntype Props = {\n  game: GameStatic\n  result: boolean | null\n  onChange: (game: GameStatic) => void\n}\n\nconst getResultText = (result: boolean | null) => {\n  if (result == null) {\n    return ''\n  }\n\n  return result ? 'VICTORY!' : 'FAIL!'\n}\n\nexport const Controls: React.FC<Props> = ({ result, game, onChange }) => {\n  const [rows, setRows] = useState(game.rows)\n  const [columns, setColumns] = useState(game.columns)\n  const [mines, setMines] = useState(game.mines)\n\n  const onSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n\n    onChange({ rows, columns, mines })\n  }\n\n  return (\n    <div className={css.controls}>\n      <form onSubmit={onSubmit}>\n        <input\n          max={MAX_CELLS}\n          min={1}\n          name='rows'\n          onChange={(e) => setRows(Number(e.currentTarget.value))}\n          type='number'\n          value={rows}\n        />\n        x\n        <input\n          name='columns'\n          type='number'\n          min={1}\n          max={MAX_CELLS}\n          value={columns}\n          onChange={(e) => setColumns(Number(e.currentTarget.value))}\n        />\n        <label>\n          Bombs:\n          <input\n            name='mines'\n            type='number'\n            min={1}\n            max={rows * columns - 1}\n            value={mines}\n            onChange={(e) => setMines(Number(e.currentTarget.value))}\n          />\n        </label>\n        <button>{getResultText(result)} Restart!</button>\n      </form>\n    </div>\n  )\n}","import React, { useState } from 'react';\nimport { GameArea } from './GameArea';\n\nimport { Controls } from './Controls';\n\nimport { GameStatic } from './utils';\n\nfunction App() {\n\n  const [gameStatic, setGame] = useState<GameStatic>({\n    columns: 32,\n    rows: 32,\n    mines: 240,\n  })\n  const [gameCounter, setGameCounter] = useState(1)\n  const [result, setResult] = useState<boolean | null>(null)\n\n  const restartGame = (g: GameStatic) => {\n    setGame(g)\n    setResult(null)\n    setGameCounter((c) => c + 1)\n  }\n\n  return <>\n    <Controls\n      result={result}\n      game={gameStatic}\n      onChange={restartGame}\n    />\n    <GameArea\n      key={gameCounter}\n      finished={result != null}\n      gameStatic={gameStatic}\n      onFinish={setResult}\n    />\n  </>;\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"tile\":\"Tile_tile__1lsqJ\",\"opened\":\"Tile_opened__2g0qM\",\"mine\":\"Tile_mine__FPytn\",\"flag\":\"Tile_flag__3Dg0B\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"area\":\"GameArea_area__H0So5\",\"container\":\"GameArea_container__hLfFA\"};"],"sourceRoot":""}